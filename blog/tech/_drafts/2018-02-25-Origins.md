---
title: Origins
date: 2018-02-25 16:06:00
---
[groupme]: https://groupme.com/
[maker-channel]: https://ifttt.com/maker_webhooks
[slack]: https://slack.com/
[otp]: https://en.wikipedia.org/wiki/One-time_password
[qrcode]: https://en.wikipedia.org/wiki/QR_code
[mime-type]: https://en.wikipedia.org/wiki/Media_type
[audio-imgur]: https://clyp.it/

I didn't even start the project, Rover, with the intention of making a multi-module deep learning robot. Originally, I had plans to use Rover as a notification bot which sent data it received from [GroupMe][groupme] to the [IFTTT Maker Channel][maker-channel] and then the Maker Channel forwarded the message to [Slack][slack]. I had Slack parse the message and notify me when it picked up on key words that usually involved some kind of event, such as the word chow, which means someone is inviting the group to a group lunch. This made it easier for me to know about important events and not get spammed by the general antics that happened on the groups I was a part of. Rover has since then evolved to be able to reply back to people and even perform certain actions that was requested of it. Although I have not added back GroupMe support since I took down the Google App Scripts version of Rover.

To be honest though, Rover isn't even my first chatbot. I once had one that lived on IRC a long time ago. It didn't have a name because I never intended for it to be for the public to use and I also followed a tutorial on how to make the bot. I don't remember for sure what language it was in. I think it was either C or Visual Basic, but I am not sure.

Rover was my second chatbot and I had written the code for Rover from scratch (minus the use of libraries, but to be fair, that doesn't take away from the status of being from scratch). The first version of Rover was designed for GroupMe, but the second version was designed for Telegram as they promised official support for bots including more advanced (or rich) content. When I wrote the Python version of Rover, I was not planning on making it modular, so I had a single loop that could just use if statements to determine what needed to be sent back if anything and I even had a basic [OTP] command that could authenticate OTP codes, generate OTP keys (used to generate the codes), and even create a [QR Code][qrcode] to send back to the user to scan. This was for testing the ability to send back media and definitely was fun to do. 

I currently have yet to add multimedia support to the modular version of Rover, but I need to give modules the ability to tell each other what type of media is being received and whether or not they can support that media type. An example is how IRC does not support the ability to share images, so in order to get around that, the IRC module would have to upload that image to some kind of hosting site and then share the link. This can get complicated real quick, especially when multiple modules are installed with the same issue and maybe the user doesn't like a service, such as Imgur. Now, this can be solved by taking a similar approach to how Android has default apps that can be set by the user when more than one app is installed. I would probably take a [mime-type][mime-type] approach. What I mean is that I will take the default app idea, but the default modules will be used depending on what file type is being processed. Such as using Imgur for pictures, or [Clyp][audio-imgur] for audio. Now, of course these default modules are there for when a communication module is not able to handle to media itself.
